use crate::{
    calc_result::{CalcResult, CellReference},
    expressions::{parser::Node, token::Error},
    model::Model,
};

pub(crate) mod binary_search;
mod date_and_time;
mod information;
mod logical;
mod lookup_and_reference;
mod mathematical;
mod statistical;
mod text;
pub(crate) mod util;
mod xlookup;

/// List of all implemented functions
#[derive(PartialEq, Clone)]
pub enum Function {
    And,
    False,
    If,
    Iferror,
    Ifna,
    Ifs,
    Not,
    Or,
    Switch,
    True,
    Xor,
    Sin,
    Cos,
    Tan,
    Asin,
    Acos,
    Atan,
    Sinh,
    Cosh,
    Tanh,
    Asinh,
    Acosh,
    Atanh,
    Pi,
    Max,
    Min,
    Round,
    Rounddown,
    Roundup,
    Sum,
    Sumif,
    Sumifs,
    Choose,
    Column,
    Columns,
    Index,
    Indirect,
    Hlookup,
    Lookup,
    Match,
    Offset,
    Row,
    Rows,
    Vlookup,
    Xlookup,
    Concat,
    Find,
    Left,
    Len,
    Lower,
    Mid,
    Right,
    Search,
    Text,
    Trim,
    Upper,
    Isnumber,
    Isnontext,
    Istext,
    Islogical,
    Isblank,
    Iserr,
    Iserror,
    Isna,
    Na,
    Average,
    Averagea,
    Averageif,
    Averageifs,
    Count,
    Counta,
    Countblank,
    Countif,
    Countifs,
    Maxifs,
    Minifs,
    Year,
    Day,
    Month,
    Date,
    Edate,
}

impl Function {
    /// Some functions in Excel like CONCAT are stringified as `_xlfn.CONCAT`.
    pub fn to_xlsx_string(&self) -> String {
        match self {
            Function::Concat => "_xlfn.CONCAT".to_string(),
            Function::Ifna => "_xlfn.IFNA".to_string(),
            Function::Ifs => "_xlfn.IFS".to_string(),
            Function::Maxifs => "_xlfn.MAXIFS".to_string(),
            Function::Minifs => "_xlfn.MINIFS".to_string(),
            Function::Switch => "_xlfn.SWITCH".to_string(),
            Function::Xlookup => "_xlfn.XLOOKUP".to_string(),
            Function::Xor => "_xlfn.XOR".to_string(),
            _ => self.to_string(),
        }
    }

    /// Gets the function
    pub fn get_function(name: &str) -> Option<Function> {
        match name {
            "AND" => Some(Function::And),
            "FALSE" => Some(Function::False),
            "IF" => Some(Function::If),
            "IFERROR" => Some(Function::Iferror),
            "IFNA" => Some(Function::Ifna),
            "IFS" => Some(Function::Ifs),
            "NOT" => Some(Function::Not),
            "OR" => Some(Function::Or),
            "SWITCH" => Some(Function::Switch),
            "TRUE" => Some(Function::True),
            "XOR" => Some(Function::Xor),

            "SIN" => Some(Function::Sin),
            "COS" => Some(Function::Cos),
            "TAN" => Some(Function::Tan),

            "ASIN" => Some(Function::Asin),
            "ACOS" => Some(Function::Acos),
            "ATAN" => Some(Function::Atan),

            "SINH" => Some(Function::Sinh),
            "COSH" => Some(Function::Cosh),
            "TANH" => Some(Function::Tanh),

            "ASINH" => Some(Function::Asinh),
            "ACOSH" => Some(Function::Acosh),
            "ATANH" => Some(Function::Atanh),

            "PI" => Some(Function::Pi),

            "MAX" => Some(Function::Max),
            "MIN" => Some(Function::Min),
            "ROUND" => Some(Function::Round),
            "ROUNDDOWN" => Some(Function::Rounddown),
            "ROUNDUP" => Some(Function::Roundup),
            "SUM" => Some(Function::Sum),
            "SUMIF" => Some(Function::Sumif),
            "SUMIFS" => Some(Function::Sumifs),
            // Lookup and Reference
            "CHOOSE" => Some(Function::Choose),
            "COLUMN" => Some(Function::Column),
            "COLUMNS" => Some(Function::Columns),
            "INDEX" => Some(Function::Index),
            "INDIRECT" => Some(Function::Indirect),
            "HLOOKUP" => Some(Function::Hlookup),
            "LOOKUP" => Some(Function::Lookup),
            "MATCH" => Some(Function::Match),
            "OFFSET" => Some(Function::Offset),
            "ROW" => Some(Function::Row),
            "ROWS" => Some(Function::Rows),
            "VLOOKUP" => Some(Function::Vlookup),
            "XLOOKUP" => Some(Function::Xlookup),

            "CONCAT" => Some(Function::Concat),
            "FIND" => Some(Function::Find),
            "LEFT" => Some(Function::Left),
            "LEN" => Some(Function::Len),
            "LOWER" => Some(Function::Lower),
            "MID" => Some(Function::Mid),
            "RIGHT" => Some(Function::Right),
            "SEARCH" => Some(Function::Search),
            "TEXT" => Some(Function::Text),
            "TRIM" => Some(Function::Trim),
            "UPPER" => Some(Function::Upper),

            "ISNUMBER" => Some(Function::Isnumber),
            "ISNONTEXT" => Some(Function::Isnontext),
            "ISTEXT" => Some(Function::Istext),
            "ISLOGICAL" => Some(Function::Islogical),
            "ISBLANK" => Some(Function::Isblank),
            "ISERR" => Some(Function::Iserr),
            "ISERROR" => Some(Function::Iserror),
            "ISNA" => Some(Function::Isna),
            "NA" => Some(Function::Na),

            "AVERAGE" => Some(Function::Average),
            "AVERAGEA" => Some(Function::Averagea),
            "AVERAGEIF" => Some(Function::Averageif),
            "AVERAGEIFS" => Some(Function::Averageifs),
            "COUNT" => Some(Function::Count),
            "COUNTA" => Some(Function::Counta),
            "COUNTBLANK" => Some(Function::Countblank),
            "COUNTIF" => Some(Function::Countif),
            "COUNTIFS" => Some(Function::Countifs),
            "MAXIFS" => Some(Function::Maxifs),
            "MINIFS" => Some(Function::Minifs),
            // Date and Time
            "YEAR" => Some(Function::Year),
            "DAY" => Some(Function::Day),
            "MONTH" => Some(Function::Month),
            "DATE" => Some(Function::Date),
            "EDATE" => Some(Function::Edate),
            _ => None,
        }
    }
}

impl ToString for Function {
    fn to_string(&self) -> String {
        match self {
            Function::And => "AND".to_string(),
            Function::False => "FALSE".to_string(),
            Function::If => "IF".to_string(),
            Function::Iferror => "IFERROR".to_string(),
            Function::Ifna => "IFNA".to_string(),
            Function::Ifs => "IFS".to_string(),
            Function::Not => "NOT".to_string(),
            Function::Or => "OR".to_string(),
            Function::Switch => "SWITCH".to_string(),
            Function::True => "TRUE".to_string(),
            Function::Xor => "XOR".to_string(),
            Function::Sin => "SIN".to_string(),
            Function::Cos => "COS".to_string(),
            Function::Tan => "TAN".to_string(),
            Function::Asin => "ASIN".to_string(),
            Function::Acos => "ACOS".to_string(),
            Function::Atan => "ATAN".to_string(),
            Function::Sinh => "SINH".to_string(),
            Function::Cosh => "COSH".to_string(),
            Function::Tanh => "TANH".to_string(),
            Function::Asinh => "ASINH".to_string(),
            Function::Acosh => "ACOSH".to_string(),
            Function::Atanh => "ATANH".to_string(),
            Function::Pi => "PI".to_string(),
            Function::Max => "MAX".to_string(),
            Function::Min => "MIN".to_string(),
            Function::Round => "ROUND".to_string(),
            Function::Rounddown => "ROUNDDOWN".to_string(),
            Function::Roundup => "ROUNDUP".to_string(),
            Function::Sum => "SUM".to_string(),
            Function::Sumif => "SUMIF".to_string(),
            Function::Sumifs => "SUMIFS".to_string(),
            Function::Choose => "CHOOSE".to_string(),
            Function::Column => "COLUMN".to_string(),
            Function::Columns => "COLUMNS".to_string(),
            Function::Index => "INDEX".to_string(),
            Function::Indirect => "INDIRECT".to_string(),
            Function::Hlookup => "HLOOKUP".to_string(),
            Function::Lookup => "LOOKUP".to_string(),
            Function::Match => "MATCH".to_string(),
            Function::Offset => "OFFSET".to_string(),
            Function::Row => "ROW".to_string(),
            Function::Rows => "ROWS".to_string(),
            Function::Vlookup => "VLOOKUP".to_string(),
            Function::Xlookup => "XLOOKUP".to_string(),
            Function::Concat => "CONCAT".to_string(),
            Function::Find => "FIND".to_string(),
            Function::Left => "LEFT".to_string(),
            Function::Len => "LEN".to_string(),
            Function::Lower => "LOWER".to_string(),
            Function::Mid => "MID".to_string(),
            Function::Right => "RIGHT".to_string(),
            Function::Search => "SEARCH".to_string(),
            Function::Text => "TEXT".to_string(),
            Function::Trim => "TRIM".to_string(),
            Function::Upper => "UPPER".to_string(),
            Function::Isnumber => "ISNUMBER".to_string(),
            Function::Isnontext => "ISNONTEXT".to_string(),
            Function::Istext => "ISTEXT".to_string(),
            Function::Islogical => "ISLOGICAL".to_string(),
            Function::Isblank => "ISBLANK".to_string(),
            Function::Iserr => "ISERR".to_string(),
            Function::Iserror => "ISERROR".to_string(),
            Function::Isna => "ISNA".to_string(),
            Function::Na => "NA".to_string(),
            Function::Average => "AVERAGE".to_string(),
            Function::Averagea => "AVERAGEA".to_string(),
            Function::Averageif => "AVERAGEIF".to_string(),
            Function::Averageifs => "AVERAGEIFS".to_string(),
            Function::Count => "COUNT".to_string(),
            Function::Counta => "COUNTA".to_string(),
            Function::Countblank => "COUNTBLANK".to_string(),
            Function::Countif => "COUNTIF".to_string(),
            Function::Countifs => "COUNTIFS".to_string(),
            Function::Maxifs => "MAXIFS".to_string(),
            Function::Minifs => "MINIFS".to_string(),
            Function::Year => "YEAR".to_string(),
            Function::Day => "DAY".to_string(),
            Function::Month => "MONTH".to_string(),
            Function::Date => "DATE".to_string(),
            Function::Edate => "EDATE".to_string(),
        }
    }
}

impl Model {
    pub(crate) fn evaluate_function(
        &mut self,
        kind: &Function,
        args: &[Node],
        cell: CellReference,
    ) -> CalcResult {
        match kind {
            // Logical
            Function::And => self.fn_and(args, cell),
            Function::False => CalcResult::Boolean(false),
            Function::If => self.fn_if(args, cell),
            Function::Iferror => self.fn_iferror(args, cell),
            Function::Ifna => self.fn_ifna(args, cell),
            Function::Ifs => self.fn_ifs(args, cell),
            Function::Not => self.fn_not(args, cell),
            Function::Or => self.fn_or(args, cell),
            Function::Switch => self.fn_switch(args, cell),
            Function::True => CalcResult::Boolean(true),
            Function::Xor => self.fn_xor(args, cell),
            // Math and trigonometry
            Function::Sin => self.fn_sin(args, cell),
            Function::Cos => self.fn_cos(args, cell),
            Function::Tan => self.fn_tan(args, cell),

            Function::Asin => self.fn_asin(args, cell),
            Function::Acos => self.fn_acos(args, cell),
            Function::Atan => self.fn_atan(args, cell),

            Function::Sinh => self.fn_sinh(args, cell),
            Function::Cosh => self.fn_cosh(args, cell),
            Function::Tanh => self.fn_tanh(args, cell),

            Function::Asinh => self.fn_asinh(args, cell),
            Function::Acosh => self.fn_acosh(args, cell),
            Function::Atanh => self.fn_atanh(args, cell),

            Function::Pi => self.fn_pi(args, cell),

            Function::Max => self.fn_max(args, cell),
            Function::Min => self.fn_min(args, cell),
            Function::Round => self.fn_round(args, cell),
            Function::Rounddown => self.fn_rounddown(args, cell),
            Function::Roundup => self.fn_roundup(args, cell),
            Function::Sum => self.fn_sum(args, cell),
            Function::Sumif => self.fn_sumif(args, cell),
            Function::Sumifs => self.fn_sumifs(args, cell),
            // Lookup and Reference
            Function::Choose => self.fn_choose(args, cell),
            Function::Column => self.fn_column(args, cell),
            Function::Columns => self.fn_columns(args, cell),
            Function::Index => self.fn_index(args, cell),
            Function::Indirect => self.fn_indirect(args, cell),
            Function::Hlookup => self.fn_hlookup(args, cell),
            Function::Lookup => self.fn_lookup(args, cell),
            Function::Match => self.fn_match(args, cell),
            Function::Offset => self.fn_offset(args, cell),
            Function::Row => self.fn_row(args, cell),
            Function::Rows => self.fn_rows(args, cell),
            Function::Vlookup => self.fn_vlookup(args, cell),
            Function::Xlookup => self.fn_xlookup(args, cell),
            // Text
            Function::Concat => self.fn_concat(args, cell),
            Function::Find => self.fn_find(args, cell),
            Function::Left => self.fn_left(args, cell),
            Function::Len => self.fn_len(args, cell),
            Function::Lower => self.fn_lower(args, cell),
            Function::Mid => self.fn_mid(args, cell),
            Function::Right => self.fn_right(args, cell),
            Function::Search => self.fn_search(args, cell),
            Function::Text => self.fn_text(args, cell),
            Function::Trim => self.fn_trim(args, cell),
            Function::Upper => self.fn_upper(args, cell),
            // Information
            Function::Isnumber => self.fn_isnumber(args, cell),
            Function::Isnontext => self.fn_isnontext(args, cell),
            Function::Istext => self.fn_istext(args, cell),
            Function::Islogical => self.fn_islogical(args, cell),
            Function::Isblank => self.fn_isblank(args, cell),
            Function::Iserr => self.fn_iserr(args, cell),
            Function::Iserror => self.fn_iserror(args, cell),
            Function::Isna => self.fn_isna(args, cell),
            Function::Na => CalcResult::new_error(Error::NA, cell, "".to_string()),
            // Statistical
            Function::Average => self.fn_average(args, cell),
            Function::Averagea => self.fn_averagea(args, cell),
            Function::Averageif => self.fn_averageif(args, cell),
            Function::Averageifs => self.fn_averageifs(args, cell),
            Function::Count => self.fn_count(args, cell),
            Function::Counta => self.fn_counta(args, cell),
            Function::Countblank => self.fn_countblank(args, cell),
            Function::Countif => self.fn_countif(args, cell),
            Function::Countifs => self.fn_countifs(args, cell),
            Function::Maxifs => self.fn_maxifs(args, cell),
            Function::Minifs => self.fn_minifs(args, cell),
            // Date and Time
            Function::Year => self.fn_year(args, cell),
            Function::Day => self.fn_day(args, cell),
            Function::Month => self.fn_month(args, cell),
            Function::Date => self.fn_date(args, cell),
            Function::Edate => self.fn_edate(args, cell),
        }
    }
}
